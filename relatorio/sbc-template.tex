\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}

%\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}  

     
\sloppy

\title{Análise de desempenho do particionamento do algoritmo \textit{QuickSort} para os métodos de \textit{Hoare} e \textit{Lomuto}}

\author{Eugenio Souza Carvalho\inst{1}, Hugo Santos Piauilino Neto\inst{1}}


\address{Departamento de Computação\\
	Universidade Federal do Piauí
  (UFPI)\\
  Teresina -- PI -- Brazil
  \email{\{hugos94,eugeniucarvalho\}@gmail.com}
}

\begin{document} 

\maketitle

\begin{abstract}
\end{abstract}
     
\begin{resumo} 
  Este trabalho apresenta uma análise de desempenho do particionamento do algoritmo de ordenação \textit{QuickSort} para os métodos propostos por \textit{Hoare} e \textit{Lomuto} \cite{cormen}, além de apresentar um resumo geral sobre a história e funcionamento do algoritmo de ordenação. 
\end{resumo}


\section{Introdução}




\section{\textit{QuickSort}}

\subsection{Dimensão de Desempenho}

\subsection{Número de Comparações}

Ambos os métodos podem ser implementados utilizando ${n - 1}$ comparações para particionar um \textit{array} de comprimento ${n}$. Isto é essencialmente ideal, uma vez que precisamos comparar cada elemento com o pivô para decidir onde colocá-lo.

\subsection{Número de Trocas}

O número de trocas é aleatório para ambos os algoritmos, dependendo dos elementos no \textit{array}. Se assumirmos permutações aleatórias, ou seja, todos os elementos são distintos e cada permutação dos elementos é igualmente provável, podemos analisar o número esperado de trocas.

Como apenas a ordem relativa conta, assumimos que os elementos são os números $1, ..., n$. Isso faz com que a discussão abaixo se torne mais fácil pois a posição de um elemento e seu valor coincidem.

\subsection{Método de \textit{Lomuto}}

A variável índice ${j}$ escaneia o \textit{array} completo e sempre que encontra um elemento ${A[j]}$ menor que o pivô ${x}$, a troca é realizada. Entre os elementos ${1, ..., n}$, exatamente ${x - 1}$ são menores que ${x}$, então nós teremos ${x-1}$ trocas se o pivô for ${x}$.

A expectativa geral então resulta do cálculo da média de todos os pivôs. Cada valor em ${\{1, ... ,n\}}$ tem a mesma probabilidade de se tornar pivô (especificamente probabilidade de  $\frac{1}{n}$), então temos
\begin{equation}
\frac{1}{n}\sum_{x=1}^{n}(x - 1) = \frac{n}{2} - \frac{1}{2}
\end{equation} 
trocas, em média, para particionar um \textit{array} de comprimento ${n}$ com o método de \textit{Lomuto}.

\subsection{Método de \textit{Hoare}}

Para este método, a análise é um pouco mais complexa. Mesmo fixando o pivô ${x}$, o número de trocas permanece aleatório.

Mais precisamente: os índices ${i}$ e ${j}$ correm um em direção ao outro até que eles se cruzem, que sempre acontece em ${x}$ (por correção do algoritmo de particionamento de \textit{Hoare}). Isto divide eficazmente o \textit{array} em duas partes: a parte esquerda que é verificada pela variável índice ${i}$ e uma parte direita que é verificada pela variável índice ${j}$.

Agora, uma troca é feita para cada par de elementos "fora do lugar", isto é, um elemento grande (maior do que ${x}$, que pertence a partição direita) que atualmente está localizado na partição esquerda e um elemento pequeno localizado na partição direita. Note-se que este par formado trabalha sempre para fora, ou seja, o número de pequenos elementos inicialmente na partição direita é igual ao número de grandes elementos na partição esquerda.

Pode-se mostrar que o número destes pares é hiper geometricamente distribuído ${Hyp(n-1,n-x,x-1)}$: para os ${n - x}$ maiores elementos nós aleatoriamente traçamos suas posições no \textit{array} e temos ${x - 1}$ posições na partição esquerda . Por conseguinte, o número esperado de pares é ${(n-x)(x-1)/(n-1)}$ dado que o pivô é ${x}$.

Finalmente, nós tiramos a média de todos os valores dos pivôs para obter o número total esperado de trocas para o método de particionamento de \textit{Hoare}:

\begin{equation}
\frac{1}{n}\sum_{x=1}^{n}\frac{(n - x)(x - 1)}{n - 1} = \frac{n}{6} - \frac{1}{3}.
\end{equation} 

Mais informações podem ser encontradas em \cite{wild}.

\subsection{Padrão de Acesso a Memória}

Ambos os algoritmos usam dois ponteiros que escaneiam o \textit{array} sequencialmente. Portanto, ambos possuem comportamento quase ideal.

\subsection{Elementos iguais e Listas Ordenadas}

\section{Resultados}

\section{Conclusão}

O método de \textit{Lomuto} é simples e de fácil implementação, porém, não deve ser utilizado quando alto desempenho é exigido.



%\begin{figure}[ht]
%\centering
%\includegraphics[width=.5\textwidth]{fig1.jpg}
%\caption{A typical figure}
%\label{fig:exampleFig1}
%\end{figure}
%
%\begin{figure}[ht]
%\centering
%\includegraphics[width=.3\textwidth]{fig2.jpg}
%\caption{This figure is an example of a figure caption taking more than one
%  line and justified considering margins mentioned in Section~\ref{sec:figs}.}
%\label{fig:exampleFig2}
%\end{figure}


\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
