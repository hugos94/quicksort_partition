\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}
\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}
\usepackage[]{algorithm2e}  

\sloppy

\title{Análise de desempenho do algoritmo \textit{quicksort} para os métodos de particionamento de \textit{Hoare} e \textit{Lomuto}}

\author{Eugenio Souza Carvalho\inst{1}, Hugo Santos Piauilino Neto\inst{1}}


\address{Departamento de Computação\\
	Universidade Federal do Piauí
  (UFPI)\\
  Teresina -- PI -- Brazil
  \email{\{hugos94,eugeniucarvalho\}@gmail.com}
}

\SetKwProg{Fn}{Function}{}{}

\begin{document} 

\maketitle

\begin{abstract}
This paper presents a performance analysis of \textit{quicksort} algorithm for partitioning methods proposed by \textit{Hoare} and \textit{Lomuto} \cite{cormen}, in addition to a general overview of the history and operation of the algorithm.
\end{abstract}

\begin{resumo} 
Este trabalho apresenta uma análise de desempenho do algoritmo de ordenação \textit{quicksort} para os métodos de particionamento propostos por \textit{Hoare} e \textit{Lomuto} \cite{cormen}, além de apresentar um resumo geral sobre a história e funcionamento do algoritmo de ordenação. 
\end{resumo}


\section{Introdução}

Problemas são questões propostas em busca de uma solução. Algoritmos são utilizados com o propósito de conceder uma solução para certo problema. Para todo problema decidível existe um algoritmo que determina uma solução para as instâncias desse problema.

Algoritmos descrevem passo a passo os procedimentos para chegar a uma solução de um problema e podem ser representados de três formas: descrição narrativa, fluxograma e a linguagem algorítmica. Neste trabalho focaremos na utilização da última forma.

Algoritmo de ordenação, em ciência da computação, é um algoritmo que coloca os elementos de uma dada sequência em uma certa ordem. Em outras palavras efetua sua ordenação completa ou parcial de acordo com uma necessidade pré-estabelecida. O objetivo da ordenação é facilitar a recuperação dos dados de uma lista.

Os mais populares algoritmos de ordenação são: \textit{insertionsort}, \textit{selectionsort}, \textit{bubblesort}, \textit{combsort}, \textit{quicksort}, \textit{mergesort}, \textit{heapsort} e \textit{shellsort}. Neste artigo, o algoritmo \textit{quicksort} será analisado, explicando o seu funcionamento, suas peculiaridades e o comportamento do seu particionamento.

\section{\textit{Quicksort}}

O \textit{quicksort} é um algoritmo de ordenação muito rápido e eficiente. Foi desenvolvido em 1961 por \textit{C.A.R. Hoare} \cite{hoare}, quando visitava a Universidade de \textit{Moscovo} como estudante.

\textit{Hoare} trabalhava em um projeto de tradução de máquina para o \textit{National Physical Laboratory}. Ele criou o \textit{quicksort} ao tentar traduzir um dicionário de inglês para russo, ordenando as palavras, tendo como objetivo reduzir o problema original em subproblemas que poderiam ser resolvidos mais fácil e rapidamente. O algoritmo só foi publicado após uma série de refinamentos.

O  \textit{quicksort} é um algoritmo de ordenação por comparação não-estável, ou seja, ele não preserva a ordem de registro de chaves iguais.

\section{Estratégia Utilizada}

O \textit{quicksort} adota a estratégia de divisão e conquista. Essa estratégia consiste em rearranjar as chaves do problema de modo que chaves "menores" precedam chaves "maiores". Em seguida o \textit{quicksort} ordena as duas sub-listas de chaves menores e maiores recursivamente até que a lista completa se encontre ordenada \cite{baase}.

O algoritmo \textit{quicksort} executa os seguintes passos:

\begin{enumerate}
	\item Escolha um elemento da lista, denominado pivô;
	\item Rearranje a lista de forma que todos os elementos anteriores ao pivô sejam menores que ele, e todos os elementos posteriores ao pivô sejam maiores que ele. Ao fim do processo o pivô estará em sua posição final e haverão duas sub-listas não-ordenadas. Essa operação é denominada particionamento;
	\item Recursivamente ordene a sub-lista dos elementos menores e a sub-lista dos elementos maiores.
\end{enumerate}

A base da recursão são as listas de tamanho zero ou um, que estão sempre ordenadas. O processo é finito, pois a cada iteração pelo menos um elemento é posto em sua posição final e não será mais manipulado na iteração seguinte.

\subsection{Pseudo-Código}

O Algoritmo~\ref{quicksort} demonstra o pseudo-código para o algoritmo  \textit{quicksort}. Podemos verificar que a função \textit{quicksort} recebe como parâmetros de entrada um \textit{array} e suas posições inicial e final. Logo, o método de particionamento escolhido é chamado e como resultado retorna um elemento pivô. Este pivô é utilizado para realizar as chamadas recursivas das sub-listas à esquerda e direita do elemento pivô. Quando as listas se tornarem de tamanho 1, o algoritmo retorna o \textit{array} devidamente ordenado.

O método \textit{Partition} do Algoritmo~\ref{quicksort} dependerá do particionamento escolhido para executar o algoritmo.

\begin{algorithm}[H]
\Fn{quicksort (A[], primeiro, ultimo)}{
	\If{$primeiro < ultimo$}{
		pivo = Partition(A, primeiro, ultimo)\;
		quicksort(A, primeiro, pivo-1)\;
		quicksort(S, pivo+1, ultimo)\;
	}
}
\KwResult{O algoritmo retorna o vetor ordenado.}
\caption{Pseudo-código do algoritmo \textit{quicksort}.}
\label{quicksort}
\end{algorithm}

\subsection{Dimensão de Desempenho}

Em uma base teórica, podemos determinar o número de comparações de elementos e trocas para comparar o desempenho. Além disso, o tempo de funcionamento real será influenciado por outros fatores, como desempenho de \textit{caches} e escalonamento de \textit{threads}.

Como será mostrado abaixo, os métodos possuem comportamento semelhante em permutações aleatórias, exceto pelo número de trocas. Aqui, o método de \textit{Lomuto} necessita de três vezes mais trocas do que o particionamento de \textit{Hoare.}

\subsection{Número de Comparações}

Ambos os métodos podem ser implementados utilizando ${n - 1}$ comparações para particionar um \textit{array} de comprimento ${n}$. Isto é essencialmente ideal, uma vez que precisamos comparar cada elemento com o pivô para decidir onde colocá-lo.

\subsection{Número de Trocas}

O número de trocas é aleatório para ambos os algoritmos, dependendo dos elementos no \textit{array}. Se assumirmos permutações aleatórias, ou seja, todos os elementos são distintos e cada permutação dos elementos é igualmente provável, podemos analisar o número esperado de trocas.

Como apenas a ordem relativa conta, assumimos que os elementos são os números $1, ..., n$. Isso faz com que a discussão abaixo se torne mais fácil pois a posição de um elemento e seu valor coincidem.

\subsection{Método de \textit{Lomuto}}

A variável índice ${j}$ escaneia o \textit{array} completo e sempre que encontra um elemento ${A[j]}$ menor que o pivô ${x}$, a troca é realizada. Entre os elementos ${1, ..., n}$, exatamente ${x - 1}$ são menores que ${x}$, então nós teremos ${x-1}$ trocas se o pivô for ${x}$.

A expectativa geral então resulta do cálculo da média de todos os pivôs. Segundo \cite{wild}, cada valor em ${\{1, ... ,n\}}$ tem a mesma probabilidade de $\frac{1}{n}$ de se tornar pivô, então serão realizadas
\begin{equation}
\frac{1}{n}\sum_{x=1}^{n}(x - 1) = \frac{n}{2} - \frac{1}{2}
\end{equation} 
trocas, em média, para particionar um \textit{array} de comprimento ${n}$ com o método de \textit{Lomuto}.

\subsection{Método de \textit{Hoare}}

Para este método, a análise é um pouco mais complexa. Mesmo fixando o pivô ${x}$, o número de trocas permanece aleatório.

Os índices ${i}$ e ${j}$ correm um em direção ao outro até que eles se cruzem, que sempre acontece em ${x}$ (por correção do algoritmo de particionamento de \textit{Hoare}). Isto divide eficazmente o \textit{array} em duas partes: a parte esquerda que é verificada pela variável índice ${i}$ e uma parte direita que é verificada pela variável índice ${j}$.

Agora, uma troca é feita para cada par de elementos "fora do lugar", isto é, um elemento grande (maior do que ${x}$, que pertence a partição direita) que atualmente está localizado na partição esquerda e um elemento pequeno que esteja localizado na partição direita. Note-se que este par formado trabalha sempre para fora, ou seja, o número de pequenos elementos inicialmente na partição direita é igual ao número de grandes elementos na partição esquerda.

\cite{wild} mostra que o número destes pares é hiper geometricamente distribuído ${Hyp(n-1,n-x,x-1)}$: para os ${n - x}$ maiores elementos nós aleatoriamente traçamos suas posições no \textit{array} e temos ${x - 1}$ posições na partição esquerda . Por conseguinte, o número esperado de pares é ${(n-x)(x-1)/(n-1)}$ dado que o pivô é ${x}$.

Segundo \cite{wild}, a média de todos os valores dos pivôs é calcula para obter o número total esperado de trocas para o método de particionamento de \textit{Hoare}:

\begin{equation}
\frac{1}{n}\sum_{x=1}^{n}\frac{(n - x)(x - 1)}{n - 1} = \frac{n}{6} - \frac{1}{3}.
\end{equation} 

Mais informações podem ser encontradas em \cite[Pág. 29]{wild}.

\subsection{Padrão de Acesso a Memória}

Ambos os métodos usam dois ponteiros que escaneiam o \textit{array} sequencialmente. Portanto, ambos possuem comportamento quase ideal.

\subsection{Elementos Iguais e Listas Ordenadas}

A performance dos algoritmos diferem mais drasticamente para listas que não estão aleatoriamente permutadas.

Em um \textit{array} já ordenado, o método de \textit{Hoare} não realiza nenhuma troca, já que não existem pares mal posicionados, ao passo que o método de \textit{Lomuto} realiza cerca de ${\frac{n}{2}}$ trocas.

A presença de elementos iguais requere cuidados especiais na utilização do algoritmo \textit{quicksort}. Considere um exemplo extremo onde um \textit{array} é preenchido apenas com elementos ${0}$. Para este \textit{array}, o método de \textit{Hoare} realiza um troca para cada par de elementos - configurando o pior caso para o particionamento de \textit{Hoare} - mas ${i}$ e ${j}$ sempre encontram-se no meio do \textit{array}. Assim, temos um particionamento ideal e o tempo total de execução permanece em ${\mathcal{O}(n \log{}n)}$.

O método de \textit{Lomuto} possui comportamento pior para o \textit{array} apenas com elementos ${0}$: a comparação ${A[j] <= x}$ sempre irá retornar verdadeira, então serão realizadas trocas para todos os elementos. Entretanto piora: após o \textit{loop}, sempre teremos ${i = n}$, então observamos o pior caso de particionamento, fazendo com que a performance do método seja degradada para ${\Theta(n^{2})}$.

\section{Materiais}

\subsection{\textit{Software}}
O algoritmo \textit{quicksort} e os métodos de \textit{Hoare} e \textit{Lomuto} foram implementados utilizando a linguagem de programação C. Para a compilação, foi utilizado o compilador gcc (TDM-2 mingw32) versão 4.4.1 2009 \cite{mingw}.

O ambiente de desenvolvimento integrado (IDE - \textit{Integrated Development Environment}) utilizado foi o Code::Blocks versão 13.12 \cite{codeblocks}.

O sistema operacional utilizado para realizar as simulações foi o \textit{Windows} 10 de 64 bits versão \textit{Professional} \cite{windows}. 

\subsection{\textit{Hardware}}

A máquina utilizada para realizar as simulações possui processador AMD Phenom(tm) II X4 B97 Processor 3.20 GHz com três pentes de memória RAM de 4 GB DDR3 2000Mhz, totalizando 12 GB de memória RAM.

\section{Resultados}

Para comparar os métodos, foram escolhidos dez diferentes tamanhos para o \textit{array}: 100, 500, 1.000, 5.000, 30.000, 80.000, 100.000, 150.000 e 200.000 elementos.

Para cada tamanho especificado foram gerados \textit{arrays} de números aleatórios, permitindo valores repetidos. Foram realizadas 20 simulações para cada tamanho em cada método. A média dos tempos de execuções foram utilizadas para realizar a análise comparativa.

Podemos verificar na Figura~\ref{graph} que para pequenos tamanhos do \textit{array} de elementos, o método de \textit{Lomuto} executou mais rápido. Porém, ao aumentarmos o tamanho do \textit{array} de elementos, o método de \textit{Hoare} apresenta melhores tempos de execução.

Isto mostra, que para pequenos conjuntos de elementos, o método de \textit{Lomuto} possui bom desempenho e que pode se equiparar ou ser até melhor que o método de \textit{Hoare}. Porém, para grandes conjuntos de elementos o método de \textit{Hoare} possui melhor desempenho.

\begin{figure}[ht]
\centering
\includegraphics[width=1\textwidth]{grafico1.png}
\caption{Gráfico comparativo entre os tempo de execução dos métodos de \textit{Hoare} e \textit{Lomuto}.}
\label{graph}
\end{figure}

\section{Conclusão}

Podemos concluir que a escolha do método de particionamento tem impacto no resultado final, tal escolha deve levar em conta o tipo de entrada que será submetida ao algoritmo. Para entradas suficientemente grandes o método de particionamento de \textit{Hoare} comporta-se melhor que o método de \textit{Lomuto} obtendo menor tempo de execução.

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
