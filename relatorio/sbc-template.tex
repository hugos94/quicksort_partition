\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}

%\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}  

     
\sloppy

\title{Análise de desempenho do particionamento do algoritmo \textit{Quicksort} para os métodos de \textit{Hoare} e \textit{Lomuto}}

\author{Eugenio Souza Carvalho\inst{1}, Hugo Santos Piauilino Neto\inst{1}}


\address{Departamento de Computação\\
	Universidade Federal do Piauí
  (UFPI)\\
  Teresina -- PI -- Brazil
  \email{\{hugos94,eugeniucarvalho\}@gmail.com}
}

\begin{document} 

\maketitle

\begin{abstract}
\end{abstract}
     
\begin{resumo} 
  Este trabalho apresenta uma análise de desempenho do particionamento do algoritmo de ordenação \textit{Quicksort} para os métodos propostos por \textit{Hoare} e \textit{Lomuto} \cite{cormen}, além de apresentar um resumo geral sobre a história e funcionamento do algoritmo de ordenação. 
\end{resumo}


\section{Introdução}




\section{\textit{Quicksort}}

\subsection{Dimensão de Desempenho}

Para uso prático, facilidade de implementação pode ser sacrificado em prol de eficiência. Em uma base teórica, podemos determinar o número de comparações de elementos e trocas para comparar o desempenho. Além disso, o tempo de funcionamento real será influenciado por outros fatores, como desempenho de \textit{caches} e escalonamento de \textit{threads}.

Como será mostrado abaixo, os algoritmos possuem comportamento semelhante em permutações aleatórias, exceto pelo número de trocas. Aqui, o método de \textit{Lomuto} necessita de três vezes a mais que o de \textit{Hoare.}

\subsection{Número de Comparações}

Ambos os métodos podem ser implementados utilizando ${n - 1}$ comparações para particionar um \textit{array} de comprimento ${n}$. Isto é essencialmente ideal, uma vez que precisamos comparar cada elemento com o pivô para decidir onde colocá-lo.

\subsection{Número de Trocas}

O número de trocas é aleatório para ambos os algoritmos, dependendo dos elementos no \textit{array}. Se assumirmos permutações aleatórias, ou seja, todos os elementos são distintos e cada permutação dos elementos é igualmente provável, podemos analisar o número esperado de trocas.

Como apenas a ordem relativa conta, assumimos que os elementos são os números $1, ..., n$. Isso faz com que a discussão abaixo se torne mais fácil pois a posição de um elemento e seu valor coincidem.

\subsection{Método de \textit{Lomuto}}

A variável índice ${j}$ escaneia o \textit{array} completo e sempre que encontra um elemento ${A[j]}$ menor que o pivô ${x}$, a troca é realizada. Entre os elementos ${1, ..., n}$, exatamente ${x - 1}$ são menores que ${x}$, então nós teremos ${x-1}$ trocas se o pivô for ${x}$.

A expectativa geral então resulta do cálculo da média de todos os pivôs. Cada valor em ${\{1, ... ,n\}}$ tem a mesma probabilidade de se tornar pivô (especificamente probabilidade de  $\frac{1}{n}$), então temos
\begin{equation}
\frac{1}{n}\sum_{x=1}^{n}(x - 1) = \frac{n}{2} - \frac{1}{2}
\end{equation} 
trocas, em média, para particionar um \textit{array} de comprimento ${n}$ com o método de \textit{Lomuto}.

\subsection{Método de \textit{Hoare}}

Para este método, a análise é um pouco mais complexa. Mesmo fixando o pivô ${x}$, o número de trocas permanece aleatório.

Mais precisamente: os índices ${i}$ e ${j}$ correm um em direção ao outro até que eles se cruzem, que sempre acontece em ${x}$ (por correção do algoritmo de particionamento de \textit{Hoare}). Isto divide eficazmente o \textit{array} em duas partes: a parte esquerda que é verificada pela variável índice ${i}$ e uma parte direita que é verificada pela variável índice ${j}$.

Agora, uma troca é feita para cada par de elementos "fora do lugar", isto é, um elemento grande (maior do que ${x}$, que pertence a partição direita) que atualmente está localizado na partição esquerda e um elemento pequeno localizado na partição direita. Note-se que este par formado trabalha sempre para fora, ou seja, o número de pequenos elementos inicialmente na partição direita é igual ao número de grandes elementos na partição esquerda.

Pode-se mostrar que o número destes pares é hiper geometricamente distribuído ${Hyp(n-1,n-x,x-1)}$: para os ${n - x}$ maiores elementos nós aleatoriamente traçamos suas posições no \textit{array} e temos ${x - 1}$ posições na partição esquerda . Por conseguinte, o número esperado de pares é ${(n-x)(x-1)/(n-1)}$ dado que o pivô é ${x}$.

Finalmente, nós tiramos a média de todos os valores dos pivôs para obter o número total esperado de trocas para o método de particionamento de \textit{Hoare}:

\begin{equation}
\frac{1}{n}\sum_{x=1}^{n}\frac{(n - x)(x - 1)}{n - 1} = \frac{n}{6} - \frac{1}{3}.
\end{equation} 

Mais informações podem ser encontradas em \cite[Pág. 29]{wild}.

\subsection{Padrão de Acesso a Memória}

Ambos os algoritmos usam dois ponteiros que escaneiam o \textit{array} sequencialmente. Portanto, ambos possuem comportamento quase ideal.

\subsection{Elementos iguais e Listas Ordenadas}

A performance dos algoritmos diferem mais drasticamente para listas que não estão aleatoriamente permutadas.

Em um \textit{array} já ordenado, o método de \textit{Hoare} não realiza nenhuma troca, já que não existem pares mal posicionados, ao passo que o método de \textit{Lomuto} realiza cerca de ${\frac{n}{2}}$ trocas.

A presença de elementos iguais requere cuidados especiais na utilização do algoritmo \textit{Quicksort}. Considere um exemplo extremo onde um \textit{array} é preenchido apenas com elementos ${0}$. Para este \textit{array}, o método de \textit{Hoare} realiza um troca para cada par de elementos - configurando o pior caso para o particionamento de \textit{Hoare} - mas ${i}$ e ${j}$ sempre encontram-se no meio do \textit{array}. Assim, temos um particionamento ideal e o tempo total de execução permanece em ${\mathcal{O}(n \log{}n)}$.

O método de \textit{Lomuto} possui comportamento pior para o \textit{array} apenas com elementos ${0}$: a comparação ${A[j] <= x}$ sempre irá retornar verdadeira, então serão realizadas trocas para todos os elementos. Entretanto piora: após o \textit{loop}, sempre teremos ${i = n}$, então observamos o pior caso de particionamento, fazendo com que a performance seja degradada para ${\Theta(n^{2})}$.

\section{Resultados}

O algoritmo \textit{Quicksort} e os métodos de \textit{Hoare} e \textit{Lomuto} foram implementados utilizando a linguagem de programação C. O ambiente de desenvolvimento integrado (IDE - Integrated Development )

Windows 10 pro
AMD Phenom(tm) II X4 B97 Processor 3.20 GHz
Sistema operacional de 64 bits

DDR3

Linguagem C

 Code::Blocks 13.12!
 
 gcc (TDM-2 mingw32) 4.4.1 2009


\section{Conclusão}

O método de \textit{Lomuto} é simples e de fácil implementação, porém, não deve ser utilizado quando alto desempenho é exigido.



%\begin{figure}[ht]
%\centering
%\includegraphics[width=.5\textwidth]{fig1.jpg}
%\caption{A typical figure}
%\label{fig:exampleFig1}
%\end{figure}
%
%\begin{figure}[ht]
%\centering
%\includegraphics[width=.3\textwidth]{fig2.jpg}
%\caption{This figure is an example of a figure caption taking more than one
%  line and justified considering margins mentioned in Section~\ref{sec:figs}.}
%\label{fig:exampleFig2}
%\end{figure}


\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
